# README

Java version: jdk1.8.0_102.jdk

Java IDE: Eclipse - neon

Instructions: To run file, insert the input and output file in a folder that is easily accessible. Run the program and insert the input file path followed by a separate input for the output file path. The user will also have the chance to add his/her own matrix to the program. This feature is optional.

If there is an error with a value, read what is printed to the console to determine where the error might lie.

### Data Structures – Justification and Implementation
Initially when thinking about the best way to construct my linked matrix object, I believed it would be best to implement the structure as a multi-linked list. Each node would consist of four pointers – one for each direction (up, right, down and left). As I began to implement this concept, I began to ponder why so many pointers were necessary. Thus, this led me to changing my implementation from a multi-linked list to a single linked list. Each node now would have one and only one pointer. The main difference between my initial structure and my new one was the information being stored within each node. Rather than creating separate lists for each node’s matric coordinate, I constructed a new object ‘NodeFeatures’ that would the data value, row and column of each node. This implementation allowed me to capture the positional data while only using a single linked list.

### Application, Design and Efficiency
Similar to the last lab, I constructed my determinant computation method to handle a single matrix along with that given matrix’s order. Any matrix inserted into the method with an order greater than 2 would then recursively call the determinant compute method until a matrix size of 2 was reached. This implementation is slightly different than my previous lab’s due to the fact that I created a second base case. The first base case remained the same in that if a matrix with an order of one was inserted into the method, the single data point would be returned. The second base case made things easier this time around in that once a matrix was down to an order of two, the method would return the cross-multiply and subtract result on the set of four data points. Instead of setting up for loops to navigate each matrix, the method would walk through each list to obtain the data and its position within the matrix.

Again, similar to my previous lab, I constructed one method to return the determinant of a matrix. However, this time with the implementation changing to a linked structure, it was necessary to create a node object as well as a linked matrix object. As mentioned before, within my ListNode class lies the NodeFeatures class that ultimately holds the data that pertains to each position in a matrix. I found holding this information here would reduce the amount of information that was needed to be stored in one node. This time around, I also constructed getters and setters for the ListNode’s data, thus making it more accessible.

The complexity of this insertion algorithm would be O(N), much like last time. Each line from the input file is read in line by line. The overall computation for one matrix depends on how many integers are inserted into the matrix making the program run in a linear fashion. Thus, no matter how many matrices are inserted into the program for computing the determinant, the insertion will take O(N). The actual computation of the determinant will be O(N^2) however because as the order of the matrix increases, the algorithm will need to check n^2 more integers and return one more minor. I noticed that even though the implementation the matrix’s data structure changed, the runtime of the algorithm did not seem to be affected.

My own opinion is that for this specific program, I would consider array-based matrices to be the better option. There is a lot of room for flexibility when constructing a linked structure but I can find more cases where arrays make more sense. Because the order of a given matrix is given, we know how much space must be allocated to our matrix structure. A linked structure would be more suitable if it was necessary to add or remove objects from the matrix space. Another advantage for a linked implementation is the amount of data that can be stored in a single node. My nodes handled data, a row and a column, but more could have been added to this. However, this is the only data that is needed which means an array-based structure should suffice.

If I had to try a different approach, I would implement a doubly linked circular list where each node would have an additional pointer pointing to the previous position. I think this could prove to be beneficial when traversing the matrix. The methods used to solve this problem traversed the array in a linear fashion moving from node to node. Adding in this backwards traversal, functional due to a previous pointer, would aid in accessing previous information. I think this could definitely help with file I/O as well.

### Learning Component
This lab was more challenging than the previous one since it was required to figure out the best way to construct the actual storage of each matrix’s data AND location. Because of this, I learned how helpful it is to make subclasses, like my NodeFeatures class, to help with data storage. I also learned how this new implementation affects file I/O. This was one area I struggled with. I found my code to be troublesome when altering the input file. Handling the NullPointerException proved to be an interesting obstacle. So much so that I could not come up with an efficient way of handling it. I figured out that my issue started because of the linked nature of my matrix. When reading in the input file, the scanner will insert a new node into each matrix for every integer. The problem arises since the insertion doesn’t stop until the matrix is filled. This means data on concerning the next matrix was being inserted into the original matrix. The main issue from all of this was programming a reference point for the scanner to check so that it could pause the insertion and check for errors. This was not necessary with the array implementation because the insertion understood the array positions and could provide a built in reference point. Nonetheless, this was a great learning opportunity.

### Iterative Implementation Consideration
An iterative solution, in my opinion, would start of with computing the stopping case first versus computing this last in the recursive solution. After returning the 1x1 matrix, a new matrix would be constructed of an order one level higher, so 2x2. This data would be pulled from the initial matrix that was inserted into the program. This same pattern would continue until the matrix reaches the order of the initial matrix. I believe this process would be less efficient than a recursive implementation because one would have to keep referencing the same starting matrix to pull all the information from instead of building off the data that was already computed like in the recursive solution. This would also be inefficient because of the amount of resources needed to construct a linked matrix. Each object needs to handle more information (data, row, column and next pointer). 

### Enhancements
I wanted to pull the same output format and error handling code from my previous work into this project to keep things comparable and clean. I also wanted to take advantage of my linked matrix’s structure and create a user friendly input request in case the user wanted to add another self-made matrix to the input set. This request asks the user for a matrix order, proceeds to walk the user through the matrix position by position, inserting a custom integer at every point and writing the result as the first matrix in the out put file. This program can also handle matrix sizes up to an order of nine.
